[TOC]
# Github Note of NeverYu
<h3>My blog: https://neveryu.github.io</h3>

<table>
    <tr>
        <td style="color:#f69;" onmouseover="this.style.cssText='color:#f69;background-color:#ccc;cursor:pointer;'" onmouseout="this.style.cssText='color:#000;'" onclick="alert('s');">面包屑导航</td>
        <td onmouseover="this.style.cssText='color:#f69;background-color:#ccc;'" onmouseout="this.style.cssText='color:#333'">银弹</td>
        <td onmouseover="this.style.cssText='color:#f69;background-color:#ccc;'" onmouseout="this.style.cssText='color:#333'">XSS</td>
        <td onmouseover="this.style.cssText='color:#f69;background-color:#ccc;'" onmouseout="this.style.cssText='color:#333'">CORS</td>
        <td onmouseover="this.style.cssText='color:#f69;background-color:#ccc;'" onmouseout="this.style.cssText='color:#333'">Foo</td>
        <td onmouseover="this.style.cssText='color:#f69;background-color:#ccc;'" onmouseout="this.style.cssText='color:#333'">Foo</td>
        <td onmouseover="this.style.cssText='color:#f69;background-color:#ccc;'" onmouseout="this.style.cssText='color:#333'">Foo</td>
    </tr>
</table>

- repository  仓库

- new repository  新仓库
 
- Initlalize this repository with a README   初始化项目仓库的时候自动创建一个readme
 
- commit    在Github中，做动词讲是：做一个版本。做名词讲：等同一个版本。

- Showing 1 changed file with 1 addition and 0 deletions. 改了一个文件，添加了一行内容，删除了0行内容。

- 1 parent 59bg4fd commit 5sda695g2dfg256re56r56r5e6aa9966aaa55 (40位的16进制数)

- Unsynced   没有同步的版本

- Revert this Commit   抵消这次版本

- Roll Back to this Commit    回滚到这个版本

- master    主要的

- merge Branches    融合分支

- Merge Commit   融合版本

- rebase   变基

- Synced   同步

- Compare  对比

- Pull Request   拉取请求

- Collaborators   合作者

- And converting them into collaborators    把他们变成合作者

- Fork  (叉)  在Github中的基本意思是拷贝

- Where should we fork this repository? 你希望把这个拷贝放到哪呢？

- This pull request can be automatically merged by project collaborators  这个pull request可以被项目的collaborator 自动融合。


### github中的快捷键
- 在issues中就某个问题回复，可以选中要回复的问题，然后按快捷键R

- 在github中，其实是有查找功能的，搜索查找快捷键T


<table>
    <tr>
        <td>响应式</td>
    </tr>
    <tr>
        <td>bootstrap</td>
    </tr>
    <tr>
        <td>sass gulp</td>
    </tr>
    <tr>
        <td>requirejs  seajs</td>
    </tr>
    <tr>
        <td>Nginx</td>
    </tr>
    <tr>
        <td>Webpack</td>
    </tr>
    <tr>
        <td>underscore.js -> backbone.js</td>
    </tr>
    <tr>
        <td>angular && Vue && react && redux</td>
    </tr>
    <tr>
        <td>nodejs</td>
    </tr>
    <tr>
        <td>koa -- 基于Node.js平台的下一代web开发框架</td>
    </tr>
    
    <tr>
        <td>一直走在Web开发前沿,公司内大部分项目都使用纯前端渲染，基于Webpack构建，React是我们页面渲染框架的标配</td>
    </tr>
    <tr>
        <td>phthon && mongodb</td>
    </tr>
    <tr>
        <td>ruby && rails</td>
    </tr>
</table>

---

## 面包屑导航
  很久很久以前，在大森林的边上住着一个贫穷的樵夫，他与妻子和两个孩子相依为命。他的儿子名叫汉赛尔，女儿名叫格莱特。后来樵夫的妻子去世了，他又给孩子们取了一个后母。后母计划把两个孩子带到森林的深处，然后趁他们睡着的时候跑掉。汉赛尔无意中知道了后母的计划，于是偷偷地把一块面包藏在了口袋里。在去森林的路上，汉赛尔悄悄地捏碎了他的面包，并不时地停下脚步，把碎面包屑撒在路上。后母顺利地趁孩子们睡着的时候溜掉了，汉赛尔和格莱特醒来时已是一片漆黑。汉赛尔安慰他的妹妹说：“等太阳一出来，我们就看得见我撒在地上的面包屑了，它一定会指给我们回家的路。”
  
  在童话里，面包屑是汉赛尔在进入森林的路上偷偷撒下的，这是一种"历史记录"的应用方式，目的是帮助你追溯来路，因为它应该是一种线性的导航方式。
  不过在网页的应用中，"追溯来路"这件事浏览器已经做的足够好了，所以“面包屑”慢慢地就变成用来表达内容归属关系的界面元素。
  
  结局：但是当太阳升起来时，他们在地上却怎么也找不到一点面包屑了，原来它们都被那些在树林里、田野上飞来飞去的鸟儿一点点地啄食了。

## 银弹
  在西方古老的传说里，有一种叫做“狼人”的可怕生物。这种生物平时和人类没有什么不同之处，但每到月圆之夜，他们就会变成狼身。当他们变成狼以后，兽性会不能控制，开始袭击普通的人类。狼人给人类带来了巨大的恐惧，因为他们是无法被一般的手段杀死的，只能用赐福过的银弹(Silver Bullet)才能杀死狼人。“银弹”因此成为了“任何能够带来极大效果的直接解决方案”的代名词。
  
## XSS
  Cross-site scripting(XSS) is a type of computer security vulnerability typically found in web applications. XSS enables attackers to inject client-side scripts into web pages viewed by other users. A cross-site scripting vulnerability may be used by attackers to bypass access controls such as the same-origin policy. Cross-site scripting carried out on websites accounted for roughly 84% of all security vulnerabilities documented by Symantec as of 2007. Their effect may range from a petty nuisance to a significant security risk, depending on the sensitivity of the data handled by the vulnerable site and the nature of and security mitigation implemented by the site's owner.   
  
## CORS
CORS : Cross origin resource sharing
CORS全称Cross-Origin Resource Sharing，是 HTML5 规范定义的如何跨域访问资源。
“Cross-origin resource sharing (CORS) is a mechanism that allows a web page to make XMLHttpRequests to another domain. Such "cross-domain" requests would otherwise be forbidden by web browsers, per the same origin security policy. CORS defines a way in which the browser and the server can interact to determine whether or not to allow the cross-origin request. It is more powerful than only allowing same-origin requests, but it is more secure than simply allowing all such cross-origin requests.” ----Wikipedia

在使用 CORS 跨域的方法中，如果程序员偷懒将 Access-Control-Allow-Origin 设置为：Access-Control-Allow-Origin:* 允许任何来自任意域的跨域请求，那么就存在被 DDos 攻击的可能。
  
## 语法糖
语法糖这个词最早在 Peter J.Landin 的论文中提出的，有意思的是，这个词跟闭包来自同一篇文章（The mechan ical evaluation of expressions，1964）。
世界上第一个语法糖就是这里的where了：
xy(x+y)
where x = a² + a√y
and y = a² + b²
 这个写法等价于
{λ(x,y).xy(x+y))}
[a² + a√y,a² + b²]
那么从这个用法和现在社区的用法来看，语法糖有这么2个特征：
1.运行时等价
语法糖的英文是 syntactic sugar ,这个 syctactic 学过编译原理的都知道什么意思，显然它是个语法级别的描述，那么它最为明显的特征，就是不涉及运行时变更。
比如 coffee 的 ->，它跟 function 完全运行时等价（废话，他就是编译到 function 的啊），所以是语法糖，而 es6 的 => 因为涉及 this 等特殊处理，所以不能算语法糖。
  
2.语法结构等价
因为原本作者用法比较简单，估计也没想太多，但是其实语法糖还有一点约束，那就是糖前糖后的语法结构在语法中所处的位置不能变，比如原来是嵌套结构，后来变成顺序结构了，这个就不能说是语法糖看，因为它影响了周围的语法环境约束，比如
```
where(1) {
  yield i ++
}
```
 
这个肯定不等价
return new lterator(......)
因为 return 和 while 在语法上不等价，它能出现的位置不一样，这就叫语法改进，而不叫语法糖。
  
## 语法盐

## 糖衣炮弹






